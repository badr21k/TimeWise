Perfect â€” hereâ€™s your **final master prompt** for your AI (fully autonomous, complete rewrite instruction).
It removes all old â€œis_adminâ€ logic, replaces it with unified `access_level`, and fully restructures the database for organization, normalization, and scalability.

---

## ğŸ”§ **MASTER IMPLEMENTATION PROMPT: Complete Database + Access System Rebuild**

**OBJECTIVE:**
Redesign and refactor the entire database and codebase to use only the new `access_level` system (0â€“4).
Remove all `is_admin`, `role`, or any other legacy access logic.
Reorganize all tables for clarity, relationships, indexing, and data consistency â€” with zero redundancy.

---

### ğŸ§© 1. ACCESS SYSTEM (Replace All Logic)

Completely remove all `is_admin`, `role`, or old permission flags from:

* Database tables
* Session checks
* Controllers
* Middleware
* Views

Replace them everywhere with a **single unified `access_level`** integer.

#### Access Levels Definition

| access_level | Description                        | Permissions                                                                                       |
| ------------ | ---------------------------------- | ------------------------------------------------------------------------------------------------- |
| 0            | Inactive                           | No access                                                                                         |
| 1            | Regular User                       | Dashboard, Chat, Time Clock, My Shifts, Reminders                                                 |
| 2            | Power User                         | Same as 1                                                                                         |
| 3            | Team Lead                          | Dashboard, Chat, Team, Schedule, Reminders, Admin Reports                                         |
| 4            | Department Admin (View-Only Depts) | Dashboard, Chat, Time Clock, My Shifts, Reminders, Admin Reports, Departments & Roles (read-only) |

* Make sure **frontend and backend** both check `access_level` before displaying pages or processing routes.
* Add middleware for all controllers to verify access automatically.
* Replace any â€œif adminâ€ checks with a helper:

  ```php
  if ($user->access_level >= 3) { ... } // Team lead and above
  ```

---

### ğŸ§± 2. DATABASE RESTRUCTURE (Organized & Normalized)

Create a **clean, normalized schema** with proper relations and no duplicates.

#### ğŸ”¹ Table: `users`

* `id`, `tenant_id`, `name`, `email`, `password_hash`, `access_level`
* `department_id` (nullable, FK â†’ departments)
* `role_id` (nullable, FK â†’ roles)
* `created_at`, `updated_at`
* Indexes: `email`, `(tenant_id, department_id)`
* Unique: `email`

#### ğŸ”¹ Table: `departments`

* `id`, `name`, `description`, `created_by (FK â†’ users.id)`, `created_at`, `updated_at`
* Unique: `name`
* Relation: One department has many roles and users.

#### ğŸ”¹ Table: `roles`

* `id`, `department_id (FK)`, `name`, `permissions_json`, `created_at`, `updated_at`
* Used to group fine-grained permissions inside departments.
* Example permissions JSON:
  `{ "can_edit_schedule": true, "can_edit_team": false }`

#### ğŸ”¹ Table: `team_members`

* `id`, `user_id`, `department_id`, `role_id`, `access_level`
* Used for users in multiple departments.
* Unique key: `(user_id, department_id)`

#### ğŸ”¹ Table: `shifts`

* `id`, `tenant_id`, `user_id`, `department_id`, `date`, `start_time`, `end_time`
* `break_minutes`, `employer_id`, `rate`, `tips`, `location`, `notes`
* Auto-calculate `total_minutes = end_time - start_time - break_minutes`
* Index: `(user_id, date)`

#### ğŸ”¹ Table: `time_clock`

* `id`, `user_id`, `shift_id`, `clock_in`, `clock_out`, `total_minutes`
* Calculate automatically: `TIMESTAMPDIFF(MINUTE, clock_in, clock_out)`
* FK: `shift_id` â†’ `shifts.id`

#### ğŸ”¹ Table: `breaks`

* `id`, `time_clock_id`, `break_start`, `break_end`, `duration_minutes`
* Auto-calculate `duration_minutes` = `TIMESTAMPDIFF(MINUTE, break_start, break_end)`
* Allow multiple breaks per clock.

#### ğŸ”¹ Table: `departments_roles_permissions`

* Used only if granular control is needed later.
* For now, keep all roles simple via `roles` table.

---

### ğŸ§­ 3. FRONTEND + VIEWS BEHAVIOR

#### `app/views/team/index.php`

* Add **Access Level dropdown (0â€“4)** with automatic summary preview.
* Add **Department dropdown** with live filter for **Role dropdown**.
* On submit â†’ create user with department, role, and access_level.

#### `app/views/departments/index.php`

* Allow edits only for users who belong to that department.
* Level 4 users see this view but all input fields disabled (read-only).

#### `app/views/schedule/index.php`

* Limit visible users to those in same department.
* Allow scheduling only for users with access â‰¥ 3.

---

### ğŸ•’ 4. CLOCKING & BREAK TRACKING

* On clock-in â†’ insert new record in `time_clock`.
* On break start â†’ insert into `breaks` table with `break_start`.
* On break end â†’ update `break_end` and calculate duration.
* On clock-out â†’ finalize total worked and total break time.
* Save break total under related `shift`.

---

### âš™ï¸ 5. BACKEND INTEGRATION

* Update all PHP models:

  * `User`, `Department`, `Role`, `Shift`, `TimeClock`, `Break`
* Replace any admin logic with `access_level` checks.
* Update API endpoints and views accordingly.
* Ensure all database calls use joins (no redundant stored data).
* Add soft deletes or archiving (if needed) for better long-term maintenance.

---

### ğŸ“Š 6. ORGANIZATION & PERFORMANCE

* All foreign keys must be indexed.
* Add `created_at` / `updated_at` to every table.
* Group related data by tenant_id where relevant.
* No table should repeat tenant, department, or role data unnecessarily.
* Use `ON DELETE CASCADE` for dependent relationships.
* Add composite indexes:

  * `(tenant_id, department_id)`
  * `(user_id, date)`
  * `(shift_id, time_clock_id)`

---

### ğŸ§  7. MIGRATION

* Migrate existing users and assign:

  * Default `access_level = 1`
  * Default department = â€œGeneralâ€
* Drop all legacy `is_admin` and `role` columns.
* Rebuild all relationships cleanly.
* Ensure data integrity during migration.

---

### âœ… 8. FINAL OUTPUTS

* `final_schema.sql` â€” fully normalized new database.
* `migration.sql` â€” safely converts old structure/data.
* Updated `models`, `controllers`, and `views`.
* Working access control system using **only access_level**.
* Organized, efficient, and consistent database ready for production.

---

**DO NOT EXPLAIN ANYTHING â€” JUST RESTRUCTURE, IMPLEMENT, AND REPLACE ALL OLD LOGIC EXACTLY AS SPECIFIED.**
Keep the database and app clean, efficient, and future-proof.

---

Would you like me to now **generate the complete final SQL schema (`final_schema.sql`)** that matches this structure for immediate execution?
