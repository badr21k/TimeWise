Perfect — here’s your **final master prompt** for your AI (fully autonomous, complete rewrite instruction).
It removes all old “is_admin” logic, replaces it with unified `access_level`, and fully restructures the database for organization, normalization, and scalability.

---

## 🔧 **MASTER IMPLEMENTATION PROMPT: Complete Database + Access System Rebuild**

**OBJECTIVE:**
Redesign and refactor the entire database and codebase to use only the new `access_level` system (0–4).
Remove all `is_admin`, `role`, or any other legacy access logic.
Reorganize all tables for clarity, relationships, indexing, and data consistency — with zero redundancy.

---

### 🧩 1. ACCESS SYSTEM (Replace All Logic)

Completely remove all `is_admin`, `role`, or old permission flags from:

* Database tables
* Session checks
* Controllers
* Middleware
* Views

Replace them everywhere with a **single unified `access_level`** integer.

#### Access Levels Definition

| access_level | Description                        | Permissions                                                                                       |
| ------------ | ---------------------------------- | ------------------------------------------------------------------------------------------------- |
| 0            | Inactive                           | No access                                                                                         |
| 1            | Regular User                       | Dashboard, Chat, Time Clock, My Shifts, Reminders                                                 |
| 2            | Power User                         | Same as 1                                                                                         |
| 3            | Team Lead                          | Dashboard, Chat, Team, Schedule, Reminders, Admin Reports                                         |
| 4            | Department Admin (View-Only Depts) | Dashboard, Chat, Time Clock, My Shifts, Reminders, Admin Reports, Departments & Roles (read-only) |

* Make sure **frontend and backend** both check `access_level` before displaying pages or processing routes.
* Add middleware for all controllers to verify access automatically.
* Replace any “if admin” checks with a helper:

  ```php
  if ($user->access_level >= 3) { ... } // Team lead and above
  ```

---

### 🧱 2. DATABASE RESTRUCTURE (Organized & Normalized)

Create a **clean, normalized schema** with proper relations and no duplicates.

#### 🔹 Table: `users`

* `id`, `tenant_id`, `name`, `email`, `password_hash`, `access_level`
* `department_id` (nullable, FK → departments)
* `role_id` (nullable, FK → roles)
* `created_at`, `updated_at`
* Indexes: `email`, `(tenant_id, department_id)`
* Unique: `email`

#### 🔹 Table: `departments`

* `id`, `name`, `description`, `created_by (FK → users.id)`, `created_at`, `updated_at`
* Unique: `name`
* Relation: One department has many roles and users.

#### 🔹 Table: `roles`

* `id`, `department_id (FK)`, `name`, `permissions_json`, `created_at`, `updated_at`
* Used to group fine-grained permissions inside departments.
* Example permissions JSON:
  `{ "can_edit_schedule": true, "can_edit_team": false }`

#### 🔹 Table: `team_members`

* `id`, `user_id`, `department_id`, `role_id`, `access_level`
* Used for users in multiple departments.
* Unique key: `(user_id, department_id)`

#### 🔹 Table: `shifts`

* `id`, `tenant_id`, `user_id`, `department_id`, `date`, `start_time`, `end_time`
* `break_minutes`, `employer_id`, `rate`, `tips`, `location`, `notes`
* Auto-calculate `total_minutes = end_time - start_time - break_minutes`
* Index: `(user_id, date)`

#### 🔹 Table: `time_clock`

* `id`, `user_id`, `shift_id`, `clock_in`, `clock_out`, `total_minutes`
* Calculate automatically: `TIMESTAMPDIFF(MINUTE, clock_in, clock_out)`
* FK: `shift_id` → `shifts.id`

#### 🔹 Table: `breaks`

* `id`, `time_clock_id`, `break_start`, `break_end`, `duration_minutes`
* Auto-calculate `duration_minutes` = `TIMESTAMPDIFF(MINUTE, break_start, break_end)`
* Allow multiple breaks per clock.

#### 🔹 Table: `departments_roles_permissions`

* Used only if granular control is needed later.
* For now, keep all roles simple via `roles` table.

---

### 🧭 3. FRONTEND + VIEWS BEHAVIOR

#### `app/views/team/index.php`

* Add **Access Level dropdown (0–4)** with automatic summary preview.
* Add **Department dropdown** with live filter for **Role dropdown**.
* On submit → create user with department, role, and access_level.

#### `app/views/departments/index.php`

* Allow edits only for users who belong to that department.
* Level 4 users see this view but all input fields disabled (read-only).

#### `app/views/schedule/index.php`

* Limit visible users to those in same department.
* Allow scheduling only for users with access ≥ 3.

---

### 🕒 4. CLOCKING & BREAK TRACKING

* On clock-in → insert new record in `time_clock`.
* On break start → insert into `breaks` table with `break_start`.
* On break end → update `break_end` and calculate duration.
* On clock-out → finalize total worked and total break time.
* Save break total under related `shift`.

---

### ⚙️ 5. BACKEND INTEGRATION

* Update all PHP models:

  * `User`, `Department`, `Role`, `Shift`, `TimeClock`, `Break`
* Replace any admin logic with `access_level` checks.
* Update API endpoints and views accordingly.
* Ensure all database calls use joins (no redundant stored data).
* Add soft deletes or archiving (if needed) for better long-term maintenance.

---

### 📊 6. ORGANIZATION & PERFORMANCE

* All foreign keys must be indexed.
* Add `created_at` / `updated_at` to every table.
* Group related data by tenant_id where relevant.
* No table should repeat tenant, department, or role data unnecessarily.
* Use `ON DELETE CASCADE` for dependent relationships.
* Add composite indexes:

  * `(tenant_id, department_id)`
  * `(user_id, date)`
  * `(shift_id, time_clock_id)`

---

### 🧠 7. MIGRATION

* Migrate existing users and assign:

  * Default `access_level = 1`
  * Default department = “General”
* Drop all legacy `is_admin` and `role` columns.
* Rebuild all relationships cleanly.
* Ensure data integrity during migration.

---

### ✅ 8. FINAL OUTPUTS

* `final_schema.sql` — fully normalized new database.
* `migration.sql` — safely converts old structure/data.
* Updated `models`, `controllers`, and `views`.
* Working access control system using **only access_level**.
* Organized, efficient, and consistent database ready for production.

---

**DO NOT EXPLAIN ANYTHING — JUST RESTRUCTURE, IMPLEMENT, AND REPLACE ALL OLD LOGIC EXACTLY AS SPECIFIED.**
Keep the database and app clean, efficient, and future-proof.

---

Would you like me to now **generate the complete final SQL schema (`final_schema.sql`)** that matches this structure for immediate execution?
